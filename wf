#!/usr/bin/env ruby
require 'json'
class WF
  class << self
    LOCAL_PREFIX = 'as-'
    def start args
      status = set_phase
      push args[1..-1], status
      switch_to_task args[0]
    end
    def push args = [], status = '#in-progress'
      if in_wf_branch
        if uncommited? && commit?(args)
          `git add .`
          `git commit -m "#{env_task} #{status} #{get_comment(args)}"`
        end
        push_task env_task
      end
    end
    def update
      if in_wf_branch
        `git pull origin master`
        pull_task env_task
      end
    end
    def close args
      push args, '#resolve-issue'
      switch_to :master
      pull_task env_task
      `git push`
      set_env_task nil
    end

    def exit
      set_env_task nil
    end

    def help
      puts <<-HELP
      Current task: #{env_task}
      Workflow helper
        Commands:
          start JIRA_TASK
          switch JIRA_TASK # same as start
          push
          close
          release [open|close|hotfix] VERSION
        All commands takes options after command:
          [(c)ommit ["comment"]]
            commit - auto commit
            comment - comment for commit
      HELP
    end

    def release_hotfix args
      version = args.first
      args = args[1..-1]
      hotfix = "hotfix/#{version}"

      restore_stash = true if uncommited?
      in_branch hotfix do
        if restore_stash
          `git stash apply`
          if commit?(args)
            `git add .`
            `git commit -m "#{get_comment(args)}"`
          end
        end
        `git push origin "#{hotfix}"`
        puts "Create tag"
        `git tag -a v#{version} -m 'hotfix version #{version}'`
        in_branch "master" do
          puts "Merge master"
          if `git merge "#{hotfix}"`
            `git push origin master`
          end
        end
        in_branch "stable" do
          puts "Merge stable"
          if `git merge "#{hotfix}"`
            `git push origin stable`
          end
        end
        `git push origin --delete #{hotfix}`
      end
    end

    def release_open args
      cmd, version = *args
      version = cmd if cmd != 'open'

      release = "release/#{version}"
      in_branch "master" do
        in_branch release do
          `git merge "master"`
          puts ' > git push'
          `git push origin "#{release}"`
        end
      end
    end
    def release_close args
      version = args.first
      release = "release/#{version}"
      in_branch "master" do
        in_branch release do
          `git push origin "#{release}"`
          puts "Create tag"
          `git tag -a v#{version} -m 'release version #{version}'`
          in_branch "master" do
            puts "Merge master"
            if `git merge "#{release}"`
              `git push origin master`
            end
          end
          in_branch "stable" do
            puts "Merge stable"
            if `git merge "#{release}"`
              `git push origin stable`
            end
          end
          `git push origin --delete #{release}`
        end
      end
    end


    def install
      puts "Install for linux-amd64"
      `mkdir tmp`
      Dir.chdir('tmp') do
        `wget https://github.com/github/hub/releases/download/v2.2.1/hub-linux-amd64-2.2.1.tar.gz`
        `tar -xzf hub-linux-amd64-2.2.1.tar.gz`
        `rm hub-linux-amd64-2.2.1.tar.gz`
        Dir.chdir('hub-linux-amd64-2.2.1') do
          puts "sudo cp hub /usr/local/bin/hub"
          `sudo cp hub /usr/local/bin/hub`
        end
      end
    end

    protected

    def set_phase
      if in_wf_branch
        puts "You are leaving #{env_task}"
        state = nil
        while !state
          puts "What is state of the task? (s/r/?)"
          state = case $stdin.gets
          when /s/ then '#stop-progress'
          when /r/ then '#resolve-issue'
          else
            puts 'Choose next one: s - stop, r - resolve'
            nil
          end
        end
        state
      end
    end
    def switch_to_task task
      switch_to "#{LOCAL_PREFIX}#{task}", :master
      pull_task task
      set_env_task task
    end

    def switch_to branch, start_point = nil, opts = nil
      unless branch?(branch)
        start_point = current_branch unless start_point
        in_branch start_point do
          __switch_to branch, "#{opts} -b "
        end
      end
      __switch_to branch, opts
    end
    def __switch_to branch, opts = nil
      `git checkout #{opts} #{branch}`
      `git pull origin #{branch}`
    end

    def set_env_task task
      File.write('.wf', JSON.dump(task))
    end
    def env_task
      JSON.load(File.read('.wf'))
    end
    def push_task task
      `git push origin "#{LOCAL_PREFIX}#{task}":"feature/#{task}"`
    end
    def pull_task task
      `git pull origin "feature/#{task}"`
    end

    def status
      `git status -b -s`.split("\n")
    end
    def in_wf_branch
      env_task && status[0].index(env_task)
    end

    def current_branch
      `git rev-parse --abbrev-ref HEAD`.split("\n")[0]
    end
    def branch? name
      `git branch --list "#{name}"`.size > 0
    end
    def in_branch branch
      return_to  = current_branch
      return yield if return_to == branch

      with_stash do
        switch_to branch
        yield
        switch_to return_to
      end
    end
    def with_stash
      if uncommited?
        `git stash`
        yield
        `git stash apply`
      else
        yield
      end
    end
    def uncommited?
      status.size > 1
    end
    def commit? args
      params_to_commit?(args) || ask_to_commit
    end
    def params_to_commit? args
      ['c','commit'].include? args[0]
    end
    def ask_to_commit
      puts "Changes"
      puts status[1..-1].join("\n")
      puts "Commit? (y/n)"
      $stdin.gets =~ /y(es)?|да/i
    end
    def get_comment args
      args[1] || ask_comment
    end
    def ask_comment
      puts "Comment for commit:"
      $stdin.gets
    end
  end
end
case ARGV[0]
when 'start', 'switch'
  WF.start ARGV[1..-1]
when 'release'
  case ARGV[1]
  when 'hotfix'
    WF.release_hotfix ARGV[2..-1]
  when 'close'
    WF.release_close ARGV[2..-1]
  else
    WF.release_open ARGV[1..-1]
  end
when 'push'
  WF.push ARGV[1..-1]
when 'update'
  WF.update
when 'close'
  WF.close ARGV[1..-1]
when 'exit'
  WF.exit
when 'install'
  WF.install
else
  WF.help
end
